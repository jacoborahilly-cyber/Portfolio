<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Interactive Canvas Portfolio</title>
    <style>
        /* CSS from previous steps */
        body { 
            overflow: hidden; 
            margin: 0; 
            padding: 0; 
            background-color: #121212; 
            font-family: Arial, sans-serif; 
            color: #E0E0E0;
        }

        #world { 
            position: absolute; 
            width: 5000px;      
            height: 5000px;     
            top: 0; 
            left: 0;
            background: 
                repeating-linear-gradient(0deg, #333 0, #333 1px, transparent 1px, transparent 100px),
                repeating-linear-gradient(-90deg, #333 0, #333 1px, transparent 1px, transparent 100px);
            background-size: 100px 100px;
        }
        
        .room-content { 
            position: absolute; 
            width: 1000px;
            min-height: 700px;
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); 
            color: #121212;
            z-index: 3;
        }
        
        /* Room Styles (unchanged) */
        #Room-Design { top: 500px; left: 500px; background-color: #FF5A5F; }
        #Room-Code { top: 3500px; left: 3500px; background-color: #1ABC9C; }
        #Room-About { top: 2500px; left: 500px; background-color: #F39C12; }
        
        /* --- NEW/UPDATED: Camera Reticle (Movable Target Center) --- */
        #camera-reticle {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 15px; 
            height: 15px;
            margin-top: -7.5px;
            margin-left: -7.5px;
            border-radius: 50%;
            background-color: white; 
            z-index: 1000;
            pointer-events: none; /* Must be transparent to clicks */
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
            opacity: 0; /* Hidden initially, shown only when selecting a path */
            transition: opacity 0.5s;
        }

        /* Navigational Arrow */
        #nav-arrow {
            position: fixed;
            top: 50%;
            left: 50%;
            margin-top: -10px; 
            margin-left: -10px;
            z-index: 1001;
            font-size: 2em;
            color: #00A6FF;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0; 
        }

        /* Reset Instructions in Bottom Left (unchanged) */
        #reset-guide {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
            border-radius: 5px;
            z-index: 1002;
            font-size: 1.1em;
            opacity: 0.8;
        }

        /* Floating Path Nodes */
        .path-node {
            position: fixed;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 999;
            opacity: 1;
            transition: transform 0.3s, opacity 0.5s;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        .path-node:hover {
            transform: scale(1.1);
        }

        /* Node Colors */
        #node-1 { background-color: #E74C3C; }
        #node-2 { background-color: #3498DB; }
        #node-3 { background-color: #2ECC71; }
        #node-4 { background-color: #F1C40F; }
        #node-5 { background-color: #9B59B6; }
        #node-6 { background-color: #E67E22; }

        .nodes-hidden {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* --- NEW: Path Visual Block CSS --- */
        .path-visual-block {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 2px;
            z-index: 2; /* Below content, above grid */
            opacity: 0.8;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>

    <div id="instruction-popup">
        Choose a **Node** to begin a guided path!
    </div>
    
    <div id="camera-reticle"></div> 
    <div id="nav-arrow">â–²</div>
    <div id="reset-guide">Press **E** to reset path / Use **WASD** to explore</div>

    <div id="node-1" class="path-node" data-path="Design" data-color="#E74C3C">1</div>
    <div id="node-2" class="path-node" data-path="Code" data-color="#3498DB">2</div>
    <div id="node-3" class="path-node" data-path="About" data-color="#2ECC71">3</div>
    <div id="node-4" class="path-node" data-path="Design" data-color="#F1C40F">4</div>
    <div id="node-5" class="path-node" data-path="Code" data-color="#9B59B6">5</div>
    <div id="node-6" class="path-node" data-path="About" data-color="#E67E22">6</div>

    <div id="indicator-design" class="indicator on-screen"></div>
    <div id="indicator-code" class="indicator on-screen"></div>
    <div id="indicator-about" class="indicator on-screen"></div>

    <div id="world">
        <section id="Room-Design" class="room-content" data-path-steps="2000,1000|1000,500|500,1500"></section>
        <section id="Room-Code" class="room-content" data-path-steps="4000,4000|3000,3500|3500,2500"></section>
        <section id="Room-About" class="room-content" data-path-steps="2500,100|1500,2000|500,2500"></section>

        <div id="spawn-center" style="position: absolute; top: 2500px; left: 2500px; width: 1px; height: 1px;"></div>
    </div>
    
    <template id="room-design-template">...</template>
    <template id="room-code-template">...</template>
    <template id="room-about-template">
        <h2>ðŸ‘¤ About Room</h2>
        <p>Learn more about **who I am**...</p>
        <p>Coordinates: (2500px, 500px)</p>
    </template>

    <script>
        const world = document.getElementById('world');
        const instructionPopup = document.getElementById('instruction-popup');
        const navArrow = document.getElementById('nav-arrow');
        const pathNodes = document.querySelectorAll('.path-node');
        const resetGuide = document.getElementById('reset-guide');
        const cameraReticle = document.getElementById('camera-reticle'); // New reticle element

        // World Dimensions
        const WORLD_SIZE = 5000;
        const HALF_WORLD = WORLD_SIZE / 2;

        // Path State Management
        let pathActive = false;
        let currentPath = [];
        let pathIndex = 0;
        const pathTolerance = 100; 

        // Camera Position Variables
        let targetX = 0; // Where the camera is being EASED to (controlled by WASD)
        let targetY = 0;
        let currentX = 0; // Current position of the camera
        let currentY = 0;
        
        // Path Target (The world coordinate the user needs to aim their reticle at)
        let pathTargetWorldX = 0;
        let pathTargetWorldY = 0;
        
        // MOVEMENT CONSTANTS
        const easing = 0.08;
        const baseSpeed = 0.5;      
        const maxSpeed = 15;        
        const accelerationRate = 1.05; 
        let currentSpeed = baseSpeed;

        // Key movement variables
        const keyMap = {};Â 
        
        // Room Data (Unchanged)
        const rooms = [
            { id: 'Room-Design', element: document.getElementById('Room-Design'), indicator: document.getElementById('indicator-design'), center: { x: 1000, y: 850 } },
            { id: 'Room-Code', element: document.getElementById('Room-Code'), indicator: document.getElementById('indicator-code'), center: { x: 4000, y: 3850 } },
            { id: 'Room-About', element: document.getElementById('Room-About'), indicator: document.getElementById('indicator-about'), center: { x: 1000, y: 2850 } }
        ];

        // Stores references to the path visual blocks
        let pathVisuals = []; 

        // --- NEW: Path Visualization Function ---
        function createPathVisuals(nodeElement, steps, color) {
            // Clean up old blocks
            pathVisuals.forEach(el => el.remove());
            pathVisuals = [];

            if (!steps || steps.length === 0) return;

            // Start position is the current camera center in world space
            const worldCenterOffset = { x: HALF_WORLD, y: HALF_WORLD };
            const startWorldX = worldCenterOffset.x;
            const startWorldY = worldCenterOffset.y;
            
            // Initial vector direction from spawn (2500, 2500) to the first step
            const startStep = steps[0];
            const dx = startStep.x - startWorldX;
            const dy = startStep.y - startWorldY;
            const angle = Math.atan2(dy, dx);
            
            // Use the angle to project the blocks
            const blockSpacing = 100; // Distance between path blocks
            const numBlocks = 5;

            for (let i = 1; i <= numBlocks; i++) {
                // Calculate position along the projected line
                const blockWorldX = startWorldX + Math.cos(angle) * (blockSpacing * i);
                const blockWorldY = startWorldY + Math.sin(angle) * (blockSpacing * i);

                const block = document.createElement('div');
                block.className = 'path-visual-block';
                block.style.backgroundColor = color;
                block.style.left = `${blockWorldX}px`;
                block.style.top = `${blockWorldY}px`;
                
                world.appendChild(block);
                pathVisuals.push(block);
            }
        }

        // --- Core Path Functions ---
        function startPath(pathName, nodeElement) {
            let roomElement = document.getElementById('Room-' + pathName);
            if (!roomElement) {
                console.error("Path not found:", pathName);
                return;
            }
            const stepsString = roomElement.getAttribute('data-path-steps');
            if (!stepsString) return;

            currentPath = stepsString.split('|').map(step => {
                const [x, y] = step.split(',').map(Number);
                return { x, y };
            });

            if (currentPath.length === 0) return;

            pathActive = true;
            pathIndex = 0;
            pathNodes.forEach(node => node.classList.add('nodes-hidden'));
            
            // Show the reticle when pathing starts
            cameraReticle.style.opacity = 1;
            
            // Draw the path blocks
            createPathVisuals(nodeElement, currentPath, nodeElement.getAttribute('data-color'));

            // Set the first coordinate target
            setTargetCoordinate(currentPath[pathIndex]); 

            resetGuide.textContent = "Align white circle with arrow to advance (Press E to reset)";
        }

        // Sets the world coordinates the user must guide the camera to
        function setTargetCoordinate(coordinate) {
            pathTargetWorldX = coordinate.x;
            pathTargetWorldY = coordinate.y;
        }
        
        function resetPath() {
            pathActive = false;
            currentPath = [];
            pathIndex = 0;
            navArrow.style.opacity = 0;
            pathNodes.forEach(node => node.classList.remove('nodes-hidden'));
            instructionPopup.textContent = "Path Complete! Choose a new Node.";
            instructionPopup.classList.remove('hidden');
            
            // Hide and remove path elements
            cameraReticle.style.opacity = 0;
            pathVisuals.forEach(el => el.remove());
            pathVisuals = [];
            
            // Re-center the world when resetting the path
            initializePosition();
            
            // Crucial: Stop residual movement
            targetX = currentX;
            targetY = currentY;

            resetGuide.textContent = "Press E to reset path / Use WASD to explore";
        }

        // --- Event Listeners ---
        pathNodes.forEach(node => {
            node.addEventListener('click', () => {
                const pathName = node.getAttribute('data-path');
                if (!pathActive) {
                    startPath(pathName, node);
                    hideInstructions(500); 
                }
            });
        });

        // 'E' Key Reset Listener (Unchanged)
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE') {
                resetPath();
            }
        });

        // WASD Key Down/Up Listeners (Handle acceleration/deceleration)
        const movementKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'];

        window.addEventListener('keydown', (e) => {
            if (movementKeys.includes(e.code)) {
                if (!keyMap[e.code]) { currentSpeed = baseSpeed; }
                keyMap[e.code] = true;
                e.preventDefault();
                hideInstructions(500); 
            }
        });

        window.addEventListener('keyup', (e) => {
            if (movementKeys.includes(e.code)) {
                keyMap[e.code] = false;
            }
            if (!Object.values(keyMap).some(v => v === true)) { 
                currentSpeed = baseSpeed;
            }
        });

        // --- Initialization and Utility ---

        function positionNodesInCircle() {
            const radius = 200; 
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const nodeDiameter = 70; 

            pathNodes.forEach((node, index) => {
                const angle = (index / pathNodes.length) * 2 * Math.PI; 
                
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                node.style.left = `${x - nodeDiameter / 2}px`;
                node.style.top = `${y - nodeDiameter / 2}px`;

                node.style.transform = `translate(-50%, -50%)`;
            });
        }

        function initializePosition() {
            loadRoomTemplates();
            
            const viewportCenterX = window.innerWidth / 2;
            const viewportCenterY = window.innerHeight / 2;
            currentX = targetX = viewportCenterX - HALF_WORLD;
            currentY = targetY = viewportCenterY - HALF_WORLD;
            world.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;

            positionNodesInCircle(); 
            window.addEventListener('resize', initializePosition);
            
            // Hide visuals initially
            cameraReticle.style.opacity = 0;
        }

        function hideInstructions(delay = 4000) {
            setTimeout(() => {
                if (!instructionPopup.classList.contains('hidden')) {
                    instructionPopup.classList.add('hidden');
                }
            }, delay);
        }

        function updateArrow() {
            if (!pathActive) {
                navArrow.style.opacity = 0;
                return;
            }

            // Calculate where the path target is on the CURRENT SCREEN
            const targetScreenX = currentX + pathTargetWorldX;
            const targetScreenY = currentY + pathTargetWorldY;
            
            const viewportCenterX = window.innerWidth / 2;
            const viewportCenterY = window.innerHeight / 2;

            // Vector from viewport center (white reticle) to path target
            const vecX = targetScreenX - viewportCenterX;
            const vecY = targetScreenY - viewportCenterY;
            
            const distance = Math.sqrt(vecX * vecX + vecY * vecY);
            
            if (distance < pathTolerance) {
                // If the user has guided the white circle close enough to the target
                pathIndex++;
                if (pathIndex < currentPath.length) {
                    // Advance to the next coordinate
                    setTargetCoordinate(currentPath[pathIndex]);
                } else {
                    // Path is complete
                    resetPath();
                    return;
                }
            }

            // Calculate rotation angle
            const angle = Math.atan2(vecY, vecX); 
            
            // Rotate the arrow icon to point toward the target
            navArrow.style.transform = `rotate(${angle + Math.PI / 2}rad) translate(0, -50px)`;
            navArrow.style.opacity = 1;
        }

        // --- Animation Loop ---
        function animate() {
            // 1. Update target based on WASD keys
            if (Object.values(keyMap).some(v => v === true)) {
                currentSpeed = Math.min(maxSpeed, currentSpeed * accelerationRate);
            } else {
                currentSpeed = baseSpeed;Â 
            }
            
            // Apply key movement directly to the camera's TARGET position
            if (keyMap['KeyA'] || keyMap['ArrowLeft']) { targetX += currentSpeed; }
            if (keyMap['KeyD'] || keyMap['ArrowRight']) { targetX -= currentSpeed; }
            if (keyMap['KeyW'] || keyMap['ArrowUp']) { targetY += currentSpeed; }
            if (keyMap['KeyS'] || keyMap['ArrowDown']) { targetY -= currentSpeed; }
            
            // 2. Apply Easing
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            
            currentX += dx * easing;
            currentY += dy * easing;

            // 3. Apply the new position
            world.style.transform = `translate3d(${Math.round(currentX)}px, ${Math.round(currentY)}px, 0)`;

            updateArrow();

            window.requestAnimationFrame(animate);
        }

        // Load Templates (Function definition kept short)
        function loadRoomTemplates() {
            document.querySelectorAll('[data-template]').forEach(roomElement => {
                const templateId = roomElement.getAttribute('data-template');
                const template = document.getElementById(templateId);
                if (template && roomElement) {
                    const clone = document.importNode(template.content, true);
                    roomElement.appendChild(clone);
                }
            });
        }

        // --- Start Execution ---
        window.onload = initializePosition;
        animate();
        hideInstructions(); 
    </script>
    
</body>
</html>
