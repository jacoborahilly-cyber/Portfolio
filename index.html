<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Interactive Canvas Portfolio</title>
    <style>
        /* CSS from previous steps */
        body { 
            overflow: hidden; 
            margin: 0; 
            padding: 0; 
            background-color: #121212; 
            font-family: Arial, sans-serif; 
            color: #E0E0E0;
            cursor: none; /* Hide default cursor */
        }

        #world { 
            position: absolute; 
            width: 5000px;      
            height: 5000px;     
            top: 0; 
            left: 0;
            background: 
                repeating-linear-gradient(0deg, #333 0, #333 1px, transparent 1px, transparent 100px),
                repeating-linear-gradient(-90deg, #333 0, #333 1px, transparent 1px, transparent 100px);
            background-size: 100px 100px;
        }
        
        .room-content { 
            position: absolute; 
            width: 1000px;
            min-height: 700px;
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); 
            color: #121212;
            z-index: 3;
        }
        
        /* Room Styles (unchanged) */
        #Room-Design { top: 500px; left: 500px; background-color: #FF5A5F; }
        #Room-Code { top: 3500px; left: 3500px; background-color: #1ABC9C; }
        #Room-About { top: 2500px; left: 500px; background-color: #F39C12; }
        
        /* --- UPDATED: Heart Cursor/Center Point (now a white circle) --- */
        #heart-cursor {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 15px; /* Smaller, cleaner circle */
            height: 15px;
            margin-top: -7.5px;
            margin-left: -7.5px;
            border-radius: 50%;
            background-color: white; /* White circle */
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }

        /* Navigational Arrow (Points from the heart) */
        #nav-arrow {
            position: fixed;
            top: 50%;
            left: 50%;
            margin-top: -10px; 
            margin-left: -10px;
            z-index: 1001;
            font-size: 2em;
            color: #00A6FF;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0; 
        }

        /* Reset Instructions in Bottom Left (unchanged) */
        #reset-guide {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
            border-radius: 5px;
            z-index: 1002;
            font-size: 1.1em;
            opacity: 0.8;
        }

        /* Floating Path Nodes */
        .path-node {
            position: fixed;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 999;
            opacity: 1;
            transition: transform 0.3s, opacity 0.5s;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            /* Transform removed here, positioning is now handled by JS for perfect circle */
        }
        .path-node:hover {
            transform: scale(1.1); /* Only scale on hover */
        }

        /* Node Colors (positioning removed from CSS) */
        #node-1 { background-color: #E74C3C; } /* Red */
        #node-2 { background-color: #3498DB; } /* Blue */
        #node-3 { background-color: #2ECC71; } /* Green */
        #node-4 { background-color: #F1C40F; } /* Yellow */
        #node-5 { background-color: #9B59B6; } /* Purple */
        #node-6 { background-color: #E67E22; } /* Orange */

        .nodes-hidden {
            opacity: 0 !important;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instruction-popup">
        Choose a **Node** to begin a guided path!
    </div>
    
    <div id="heart-cursor"></div> <div id="nav-arrow">▲</div>
    <div id="reset-guide">Press **E** to reset path / Use **WASD** to explore</div>

    <div id="node-1" class="path-node" data-path="design">1</div>
    <div id="node-2" class="path-node" data-path="code">2</div>
    <div id="node-3" class="path-node" data-path="about">3</div>
    <div id="node-4" class="path-node" data-path="empty1">4</div>
    <div id="node-5" class="path-node" data-path="empty2">5</div>
    <div id="node-6" class="path-node" data-path="empty3">6</div>

    <div id="indicator-design" class="indicator on-screen"></div>
    <div id="indicator-code" class="indicator on-screen"></div>
    <div id="indicator-about" class="indicator on-screen"></div>

    <div id="world">
        <section id="Room-Design" class="room-content" data-path-steps="2000,1000|1000,500|500,1500"></section>
        <section id="Room-Code" class="room-content" data-path-steps="4000,4000|3000,3500|3500,2500"></section>
        <section id="Room-About" class="room-content" data-path-steps="2500,100|1500,2000|500,2500"></section>

        <div id="spawn-center" style="position: absolute; top: 2500px; left: 2500px; width: 1px; height: 1px;"></div>
    </div>
    
    <template id="room-design-template">...</template>
    <template id="room-code-template">...</template>
    <template id="room-about-template">...</template>

    <script>
        const world = document.getElementById('world');
        const instructionPopup = document.getElementById('instruction-popup');
        const navArrow = document.getElementById('nav-arrow');
        const pathNodes = document.querySelectorAll('.path-node');
        const resetGuide = document.getElementById('reset-guide');

        // World Dimensions
        const WORLD_SIZE = 5000;
        const HALF_WORLD = WORLD_SIZE / 2;

        // Path State Management
        let pathActive = false;
        let currentPath = [];
        let pathIndex = 0;
        const pathTolerance = 50; 

        // Target/Current positions
        let targetX = 0;
        let targetY = 0;
        let currentX = 0;
        let currentY = 0;
        
        // MOVEMENT CONSTANTS
        const easing = 0.08;
        const guidedEasing = 0.05; // Slower/steadier move when guiding
        
        // Acceleration Variables (for exponential speed, used when free-roaming)
        const baseSpeed = 0.5;      
        const maxSpeed = 15;        
        const accelerationRate = 1.05; 
        let currentSpeed = baseSpeed;

        // Key movement variables
        const keyMap = {}; 
        
        // Room Data (Unchanged)
        const rooms = [
            { id: 'Room-Design', element: document.getElementById('Room-Design'), indicator: document.getElementById('indicator-design'), center: { x: 1000, y: 850 } },
            { id: 'Room-Code', element: document.getElementById('Room-Code'), indicator: document.getElementById('indicator-code'), center: { x: 4000, y: 3850 } },
            { id: 'Room-About', element: document.getElementById('Room-About'), indicator: document.getElementById('indicator-about'), center: { x: 1000, y: 2850 } }
        ];

        // --- Core Path Functions ---
        function startPath(pathName) {
            let roomElement = document.getElementById('Room-' + pathName);
            if (!roomElement) {
                console.error("Path not found:", pathName);
                return;
            }
            const stepsString = roomElement.getAttribute('data-path-steps');
            if (!stepsString) return;

            currentPath = stepsString.split('|').map(step => {
                const [x, y] = step.split(',').map(Number);
                return { x, y };
            });

            if (currentPath.length === 0) return;

            pathActive = true;
            pathIndex = 0;
            pathNodes.forEach(node => node.classList.add('nodes-hidden'));
            navArrow.style.opacity = 1;
            setNextTarget();

            // Update instructions
            resetGuide.textContent = "Press E to reset path";
        }

        function setNextTarget() {
            if (pathIndex < currentPath.length) {
                const nextStep = currentPath[pathIndex];
                
                const viewportCenterX = window.innerWidth / 2;
                const viewportCenterY = window.innerHeight / 2;

                // Set target translation to center the next step
                targetX = viewportCenterX - nextStep.x;
                targetY = viewportCenterY - nextStep.y;

            } else {
                // Path finished
                resetPath();
            }
        }
        
        function resetPath() {
            pathActive = false;
            currentPath = [];
            pathIndex = 0;
            navArrow.style.opacity = 0;
            pathNodes.forEach(node => node.classList.remove('nodes-hidden'));
            instructionPopup.textContent = "Path Complete! Choose a new Node.";
            instructionPopup.classList.remove('hidden');
            
            // Re-center the world when resetting the path
            initializePosition();

            // Update instructions
            resetGuide.textContent = "Press E to reset path / Use WASD to explore";
        }

        // --- Event Listeners ---
        pathNodes.forEach(node => {
            node.addEventListener('click', () => {
                const pathName = node.getAttribute('data-path');
                startPath(pathName.replace('empty', 'Design')); // Simple mapping for empty nodes
                hideInstructions(500); 
            });
        });

        // 'E' Key Reset Listener
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE') {
                resetPath();
            }
        });

        // WASD Listener (Crucial fix for free-roam)
        window.addEventListener('keydown', (e) => {
            if (movementKeys.includes(e.code)) {
                if (pathActive) {
                    e.preventDefault(); // Lock movement during guide
                } else {
                    // FREE ROAM LOGIC (from previous smooth version)
                    if (!keyMap[e.code]) { currentSpeed = baseSpeed; }
                    keyMap[e.code] = true;
                    e.preventDefault();
                    hideInstructions(500); // Hide initial instructions if user starts moving
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (movementKeys.includes(e.code)) {
                keyMap[e.code] = false;
            }
            if (!Object.values(keyMap).some(v => v === true)) { currentSpeed = baseSpeed; }
        });

        // --- Initialization and Utility ---

        // NEW: Function to calculate and position nodes in a circle
        function positionNodesInCircle() {
            const radius = 200; // Distance from center in pixels
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const nodeDiameter = 70; // From CSS

            pathNodes.forEach((node, index) => {
                const angle = (index / pathNodes.length) * 2 * Math.PI; // Calculate angle
                
                // Calculate position on the circle circumference
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                // Set CSS position, adjusting for the node's own size (70px)
                node.style.left = `${x - nodeDiameter / 2}px`;
                node.style.top = `${y - nodeDiameter / 2}px`;
            });
        }

        function initializePosition() {
            loadRoomTemplates();
            // 1. Center the view
            const viewportCenterX = window.innerWidth / 2;
            const viewportCenterY = window.innerHeight / 2;
            currentX = targetX = viewportCenterX - HALF_WORLD;
            currentY = targetY = viewportCenterY - HALF_WORLD;
            world.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;

            // 2. Position the selection nodes
            positionNodesInCircle(); 
        }

        function hideInstructions(delay = 4000) {
            setTimeout(() => {
                if (!instructionPopup.classList.contains('hidden')) {
                    instructionPopup.classList.add('hidden');
                }
            }, delay);
        }

        function updateArrow() {
            if (!pathActive) {
                navArrow.style.opacity = 0;
                return;
            }

            const currentTarget = currentPath[pathIndex];
            
            // Calculate direction vector from heart center (viewport center) to target
            const targetScreenX = currentX + currentTarget.x;
            const targetScreenY = currentY + currentTarget.y;
            
            const viewportCenterX = window.innerWidth / 2;
            const viewportCenterY = window.innerHeight / 2;

            const vecX = targetScreenX - viewportCenterX;
            const vecY = targetScreenY - viewportCenterY;
            
            const distance = Math.sqrt(vecX * vecX + vecY * vecY);
            
            if (distance < pathTolerance) {
                pathIndex++;
                setNextTarget();
                return;
            }

            // Calculate rotation angle
            const angle = Math.atan2(vecY, vecX); 
            navArrow.style.transform = `rotate(${angle + Math.PI / 2}rad)`;
        }

        // --- Animation Loop ---
        function animate() {
            let dx, dy;

            if (pathActive) {
                // GUIDED PATH MOVEMENT
                dx = targetX - currentX;
                dy = targetY - currentY;
                currentX += dx * guidedEasing;
                currentY += dy * guidedEasing;

            } else {
                // FREE ROAM MOVEMENT (WASD)
                if (Object.values(keyMap).some(v => v === true)) {
                    currentSpeed = Math.min(maxSpeed, currentSpeed * accelerationRate);
                } else {
                    currentSpeed = baseSpeed; 
                }
                if (keyMap['KeyA'] || keyMap['ArrowLeft']) { targetX += currentSpeed; }
                if (keyMap['KeyD'] || keyMap['ArrowRight']) { targetX -= currentSpeed; }
                if (keyMap['KeyW'] || keyMap['ArrowUp']) { targetY += currentSpeed; }
                if (keyMap['KeyS'] || keyMap['ArrowDown']) { targetY -= currentSpeed; }
                
                dx = targetX - currentX;
                dy = targetY - currentY;
                currentX += dx * easing;
                currentY += dy * easing;
            }

            world.style.transform = `translate3d(${Math.round(currentX)}px, ${Math.round(currentY)}px, 0)`;

            updateArrow();

            window.requestAnimationFrame(animate);
        }

        // Load Templates (Function definition kept short)
        function loadRoomTemplates() {
            document.querySelectorAll('[data-template]').forEach(roomElement => {
                const templateId = roomElement.getAttribute('data-template');
                const template = document.getElementById(templateId);
                if (template && roomElement) {
                    const clone = document.importNode(template.content, true);
                    roomElement.appendChild(clone);
                }
            });
        }

        // --- Start Execution ---
        window.onload = initializePosition;
        animate();
        hideInstructions(); 
    </script>
    
</body>
</html>
